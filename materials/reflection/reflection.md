# Reflection.
Reflection in computing is the ability of a program to examine its own structure, particularly through types; it's a form of metaprogramming. It's also a great source of confusion.

Важно понимать, что как только вы начнёте четко разделять абстракции "поведения" и "данных" — вы начнёте более четко понимать назначение и правильный способ использования интерфейсов в Go. Human и Speaker — ортогональны. Human может с легкостью удовлетворять ещё 10-ти интерфейсам (Walker, Listener, Player, Programmer, etc), а Speaker может быть удовлетворён десятками типов, даже из других пакаджей (Robot, Animal, Computer, etc). И всё это, с минимальными накладными синтаксическими расходами, что, опять же, важно в больших кодовых базах.

Интерфейс создается потребителем (consumer), а не продюсером (producer).

### What is interface{}?
`interface{}` -> пустое множество ∅ методов и реализуется любым значением.
Переменная типа интерфейса хранит пару: конкретное значение, присвоенное переменной, и дескриптор типа этого значения. _( (значение, тип) --> (tty, *os.File) )_.

```go
type iface struct {
    tab  *itab // это указатель на Interface Table или itable — структуру, которая хранит некоторые метаданные о типе и список методов, используемых для удовлетворения интерфейса.
    data unsafe.Pointer // указывает на фактическую переменную с конкретным (статическим) типом,
}

p := Person{Name: "John", Age: 30}

// reflect.TypeOf работает с метаданными (tab)
t := reflect.TypeOf(p)

// Префикс main появляется потому, что это полное имя типа, включающее имя пакета. В Go каждый тип имеет полное имя, которое состоит из имени пакета и имени типа. Это важно для избежания конфликтов имен между пакетами.
fmt.Printf("Type: %v\n", t)                    // main.Person
 // Можно получить только имя типа без пакета
fmt.Printf("Type name: %v\n", t.Name()) // Dog
// Или только имя пакета
fmt.Printf("Package: %v\n", t.PkgPath()) // main

fmt.Printf("Kind: %v\n", t.Kind())             // struct
fmt.Printf("NumField: %v\n", t.NumField())     // 2
fmt.Printf("Field(0): %v\n", t.Field(0).Name)  // Name

// reflect.ValueOf работает с самим значением (data)
v := reflect.ValueOf(p)
fmt.Printf("Value: %v\n", v)                   // {John 30}
fmt.Printf("CanSet: %v\n", v.CanSet())         // false
fmt.Printf("Field(0): %v\n", v.Field(0))       // John
```

```go

  var r io.Reader
  tty, err := os.OpenFile("/dev/tty", os.O_RDWR, 0)
  if err != nil {
    return nil, err
  }
  // r содержит (значение, тип) --> (tty, *os.File)
  // При этом тип *os.File реализует методы, отличные от Read()
  // даже если значение интерфейса обеспечивает доступ только к методу Read(), значение внутри несет всю информацию о типе этого значения
  r = tty 

  /*
    Выражение в этом присваивании является утверждением типа
    оно утверждает, что элемент внутри r также реализует io.Writer, и поэтому мы можем назначить его w. После назначения w будет содержать пару (tty, *os.File). Это та же пара, что и в r. Статический тип интерфейса определяет, какие методы могут быть вызваны у интерфейсной переменной, хотя конкретное значение внутри может иметь более широкий набор методов.
  */
  var w io.Writer
  w = r.(io.Writer)

  var empty interface{}
  empty = w
```


### Reflect 

На базовом уровне reflect является всего лишь механизмом для изучения пары тип и значение, хранящейся внутри переменной интерфейса `reflect.TypeOf()` -> `reflect.Type` и `reflect.ValueOf()` -> `reflect.Value`.

Метод `Interface()` используется для преобразования `reflect.Value` обратно в обычное значение Go. Это важно, потому что `reflect.Value` - это специальный тип, который оборачивает значение для работы с рефлексией.

#### TypeOf:
- Показывает полный тип, включая пользовательские типы
- Учитывает алиасы типов  
- Полезен, когда нужно знать точный тип значения

#### Kind():
- Показывает базовый тип (int, string, struct, slice и т.д.)
- Игнорирует пользовательские типы
- Полезен для проверки базовой природы значения

#### Основные методы:
- `reflect.TypeOf()`: возвращает `reflect.Type`, представляющий тип переменной
- `reflect.ValueOf()`: возвращает `reflect.Value`, представляющий значение переменной
- `Interface()`: возвращает `interface{}`, представляющий текущее значение. Это позволяет извлекать оригинальные данные из `reflect.Value`
- `Kind()`: возвращает `reflect.Kind`, представляющий конкретный тип данных, например, Int, Float64, Struct, и т.д.
- `NumField()` и `Field(i int)`: используются для работы со структурами, позволяют получить количество полей и доступ к каждому полю соответственно
- `NumMethod()` и `Method(i int)`: используются для работы с методами, предоставляя доступ к методу и его характеристикам

Elem() используется для получения значения, на которое указывает указатель, или элемента интерфейса. Это особенно полезно при работе с указателями и интерфейсами.

Доп материалы:
Про unsafe.Pointer + reflection, например как изменять приватные поля.
https://habr.com/ru/companies/otus/articles/862854/

## Приведение типов (Type Conversion)
- **Компиляция**: происходит на этапе компиляции
- **Память**: изменяет интерпретацию битов в памяти
- **Безопасность**: может быть небезопасным (особенно с unsafe.Pointer)

## Утверждение типов (Type Assertion)
- **Выполнение**: происходит во время выполнения
- **Интерфейсы**: работает только с интерфейсами
- **Проверка**: проверяет, реализует ли значение конкретный тип